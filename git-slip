#!/usr/bin/env zsh

# git-slip
# copyright 2020 Henry Bley-Vroman
#
# Slip your feature and staging branches to the tip of the trunk
#
# Requirements:
# - Git >=2.23
# - yq https://github.com/mikefarah/yq
# - recommended: git-rerere, as it can automatically continue after a
#   conflict if all conflicts are rerere-resolved. Check with
#       git config rerere.enabled
#   and enable with
#       git config rerere.enabled true
#
# Useage:
# 1. Create a `git-slip.yaml`. For example, to
#   - rebase `branch_1` and `branch_2` with `upstream_1`
#   - rebase `branch_3` with `upstream_2`
#   - create a "stage" `branch_4` that starts at `start_point_1` and
#     merges in first `branch_1` and then `branch_2`
#   - create a "stage" `branch_5` that starts at `start_point_2` and
#     merges branches `branch_1` and `branch_3` in an octopus merge

#   ```yaml
#   rebase:
#     upstream_1:
#       - branch_1
#       - branch_2
#     upstream_2: branch_3
#   stage:
#     start_point_1:
#       branch_4:
#         - branch_1
#         - branch_2
#     start_point_2:
#       branch_5: branch_1 branch_3
#   ```
# 2. Run `git slip`
#
# To use a different file, pass it as an argument
#     git slip path/to/file.(yaml|yml)
#
# Works best with git-rerere, as it can automatically continue after a conflict
# if all conflicts are rerere-resolved.


log_failure() {
  print -P "$failure_color${prefix}Did not succeed%f"
}

log_message() {
  print -P "$log_color${prefix}$1%f"
}

log_success() {
  print -P "$success_color${prefix}Succeeded%f"
}

rebase() {
  local branch
  local branch_value
  local -a branch_values
  local exit_code
  local file
  local upstream
  local upstream_path
  local -a upstream_paths

  log_message "Rebasing..."

  file=$1

  upstream_paths=( ${(f)"$(yq r --printMode p $file 'rebase.*')"} )
  for upstream_path in $upstream_paths; do
    branch_values=( ${(f)"$(yq r $file $upstream_path)"} )
    upstream=${upstream_path#rebase.}
    for branch_value in $branch_values; do
      branch=${branch_value#- }
      run git rebase ${upstream_path#rebase.} $branch \
        || resolve_conflict \
        || exit
      log_divergence $branch
    done
  done
}

resolve_conflict() {
  local conflicted_files
  log_message "Attempting automatic continuation"

  conflicted_files=$(git diff --name-only --diff-filter=U)

  if [[ $(git config rerere.enabled) == true \
        && -z $(git rerere diff) \
        && -n $conflicted_files ]]; then
    print -P "$log_color${prefix}All conflicts resolved by git-rerere%f"
    run git add $conflicted_files \
      || return 1
    run git commit --no-edit \
      || return 1
  else
    log_failure
    return 1
  fi
  return 0
}

run() {
  # Input: a command
  #
  # log_message the command, run it, log_message whether it
  # succeeded or failed, and return its return 1 code.
  # Drop-in replacement for just running it.

  local -i exit_code

  print -P "$run_color$prefix$@%f"
  $@
  exit_code=$?

  if (( exit_code )); then
    log_failure
  else
    log_success
  fi

  return $exit_code
}

stage() {
  local branch
  local branch_path
  local -a branch_paths
  local commit
  local commit_path
  local -a commit_paths
  local file
  local start_point
  local start_point_path
  local -a start_point_paths

  log_message "Staging..."

  file=$1

  start_point_paths=( ${(f)"$(yq r --printMode p $file 'stage.*')"} )

  for start_point_path in $start_point_paths; do
    start_point=${start_point_path#stage.}
    branch_paths=( ${(f)"$(yq r --printMode p $file $start_point_path.\*)"} )

    for branch_path in $branch_paths; do
      branch=${branch_path#$start_point_path.}
      commit_paths=( ${(f)"$(yq r $file $branch_path)"} )

      run git switch -C $branch $start_point \
        || log_failure && return 1

      for commit_path in $commit_paths; do
        commit=${commit_path#- }
        run git merge --no-ff --no-edit $commit \
          || resolve_conflict \
          || exit
      done

      log_divergence $branch
      run git switch -
    done
  done
}

log_divergence() {
  # Input: a branch name
  #
  # If the branch has diverged from its upstream, say so immediately
  # and at the of the script

  # Commit ID for the upstream, if there is an upstream
  local message
  local upstream
  upstream=$(git rev-parse $1@{u} 2>/dev/null)

  # If there's an upstream and its commit ID is not the same as the local branch's
  if [[ -n $upstream && $upstream != $(git rev-parse $1) ]]; then
    message="$warn_color${prefix}$1 has diverged from its upstream%f"
    print -P $message
    messages+="$message\\n"
  fi
}

'builtin' 'setopt' prompt_percent

failure_color=
log_color=
messages=
prefix="  â–¶ "
run_color=
success_color=
warn_color=

if ! (( ${+NO_COLOR} )); then
  autoload -U colors && colors
  failure_color="%F{red}"
  log_color="%F{magenta}"
  run_color="%F{blue}"
  success_color="%F{green}"
  warn_color="%F{yellow}"
fi


local file=${1:-$PWD/git-slip.yaml}

rebase $file
stage $file
[[ -n $messages ]] && print -P \\n$messages
