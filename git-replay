#!/usr/bin/env zsh

# git-replay
# copyright 2020 Henry Bley-Vroman
#
# Automate Git rebases and stage creation
# https://github.com/olets/git-replay


add_todo() {
	echo $1 >> $todo_path
	# echo $1
}

clean() {
  local -a branches

  branches=( ${(f)"$(git for-each-ref --format='%(refname:short)' refs/heads/$BACKUP_PREFIX)"} )
  [[ -z $branches ]] && print_warning "No backup found" && return

  print_log "Deleting all backups"

  if (( quiet )); then
	  git branch --quiet -D $branches
	else
		print_log "git branch ${quiet:+--quiet }-D $branches"
	  git branch -D $branches
	fi
}

do_todos() {
	local cmd
	local -a cmd_words
	local todo

	todo=$(head -n 1 $todo_path)

	if [[ -n $todo ]]; then
		todos_updated=$(mktemp ${TMPDIR:-/tmp/}git-replay/git-replay-todos_updated.XXXXXX)
		sed '1d' $todo_path > $todos_updated
		mv $todos_updated $todo_path

		cmd_words=( ${(z)todo} )

		case $cmd_words[1] in
			merge)
				local branch
				local commit
				local -i the_exit_code

				branch=$cmd_words[3]
				commit=$cmd_words[2]

				print_log "Merging $commit into $branch"
				(( quiet )) || print_log "git merge ${quiet:+"--quiet "}--rerere-autoupdate --no-ff --no-edit $commit"

				if ! (( dry_run )); then
					if (( quiet )); then
						git merge --quiet --rerere-autoupdate --no-ff --no-edit $commit
			      the_exit_code=$?
					else
						git merge --rerere-autoupdate --no-ff --no-edit $commit
			      the_exit_code=$?
					fi
		    fi

				if (( the_exit_code )); then
					# set -x
					if [[ $the_exit_code == 128 || ! $(git config rerere.enabled) == true ]]; then
						print_error "Cannot continue"
					fi

					if [[ -n $(git rerere remaining) ]]; then
						print_error "Resolve conflicts, then run \`git rerere && git merge --abort && git replay'"
					fi

					conflicted_files=$(git diff --name-only --diff-filter=U)

			    if [[ -n $conflicted_files ]]; then
				    print_log "Adding rerere-resolved conflicted files"
				    (( quiet )) || print_log "git add $conflicted_files"
			      git add $conflicted_files
			    fi

			    # (( quiet )) || print_log "git commit --no-edit"
			    git commit --no-edit
		    fi
				;;
			rebase)
				local branch
				local -i the_exit_code
				local upstream

				branch=$cmd_words[3]
				upstream=$cmd_words[2]

	      if (( back_up )); then
	      	print_log "Backing up $branch"
				  (( quiet )) || print_log "git branch ${quiet:+"--quiet "}--force git-renew/$branch $branch"

				  if ! (( dry_run )); then
						if (( quiet )); then
							git branch --quiet --force git-renew/$branch $branch || return
						else
							git branch --force git-renew/$branch $branch || return
						fi
					fi
			  fi

				print_log "Rebasing $branch off $upstream"
				(( quiet )) || print_log "git rebase ${quiet:+"--quiet "}--rerere-autoupdate $upstream $branch"

				if ! (( dry_run )); then
					if (( quiet )); then
						git rebase --quiet --rerere-autoupdate $upstream $branch
			      the_exit_code=$?
					else
						git rebase --rerere-autoupdate $upstream $branch
			      the_exit_code=$?
					fi
	      fi

				if (( the_exit_code )); then
					if [[ $the_exit_code == 128 || ! $(git config rerere.enabled) == true ]]; then
						print_error "Cannot continue"
					fi

					if [[ -n $(git rerere remaining) ]]; then
						print_error "Resolve conflicts, then run \`git rerere && git rebase --abort && git replay'"
					fi

					conflicted_files=$(git diff --name-only --diff-filter=U)

			    if [[ -n $conflicted_files ]]; then
				    print_log "Adding rerere-resolved conflicted files"
				    (( quiet )) || print_log "git add $conflicted_files"
			      git add $conflicted_files
			    fi

			    (( quiet )) || print_log "git rebase --continue"
			    git rebase --continue || return
		    fi

	      local message
			  local remote_sha
			  remote_sha=$(git rev-parse $branch@{u} 2>/dev/null)

				[[ -n $remote_sha && $remote_sha != $(git rev-parse $branch) ]] && print_warning "$branch has diverged from its upstream"
				;;
			stage-end)
				branch=$cmd_words[2]
				if ! (( dry_run )); then
		      local message
				  local remote_sha
				  remote_sha=$(git rev-parse $branch@{u} 2>/dev/null)

					[[ -n $remote_sha && $remote_sha != $(git rev-parse $branch) ]] && print_warning "$branch has diverged from its upstream"

		      # print_log "Checking out the previously checked-out branch"
					# if (( quiet )); then
					# 	git switch --quiet - || return
					# else
					# 	git switch - || return
					# fi
	      fi
	      ;;
			stage-start)
				local branch
				local start_point

				branch=$cmd_words[2]
				start_point=$cmd_words[3]

	      if (( back_up )); then
	      	print_log "Backing up $branch"
				  (( quiet )) || print_log "git branch ${quiet:+"--quiet "}--force git-renew/$branch $branch"

				  if ! (( dry_run )); then
						if (( quiet )); then
							git branch --quiet --force git-renew/$branch $branch || return
						else
							git branch --force git-renew/$branch $branch || return
						fi
					fi
			  fi

				print_log "Resetting $branch to $start_point"
	      (( quiet )) || print_log "git switch ${quiet:+"--quiet "}-C $branch $start_point"

	      if ! (( dry_run )); then
					if (( quiet )); then
						git switch --quiet -C $branch $start_point || return
					else
						git switch -C $branch $start_point || return
					fi
		    fi
				;;
			*) ;;
		esac

		do_todos
	fi

	rm -rf $todo_dir
	# this end is hit many times. why??
}

print_error() {
  print -P "$color[error]$@%f"
  exit 1
}

print_log() {
  (( quieter )) || print -P "$color[log]$@%f"
}

print_success() {
  (( quieter )) || print -P "$color[success]$@%f"
}

print_warning() {
  (( quieter )) || print -P "$color[warning]$@%f"
  warnings+=( "$@" )
}

main() {
	while (( $# )); do
		case $1 in
			--continue)
				[[ -f $todo_path ]] || print_error "fatal: No replay in progress?"
				queue_rebases=0
				queue_stages=0
				shift
				;;
			--back-up)
				back_up=1
				shift
				;;
			--dry-run)
				dry_run=1
				shift
				;;
			--file)
				file=$2
				shift 2
				;;
			-q|\
			--quiet)
				quiet=1
				shift
				;;
			-qq|\
			--quieter)
				quieter=1
				shift
				;;
			clean)
				clean
				return
				;;
			rebase)
				queue_stages=0
				shift
				;;
			restore)
				restore_backup
				return
				;;
			stage)
				queue_rebases=0
				shift
				;;
			*)
				print_error "git-replay unknown option"
				;;
		esac
	done

  if ! [[ -f $file ]]; then
    print_error "Could not find the file $file"
  fi

	mkdir -p $todo_dir
	touch $todo_path

	(( queue_rebases )) && write_rebase_todos
	(( queue_stages )) && write_staging_todos

	do_todos

	print_log git-replay completed

	[[ -n $warnings ]] || return

	echo

	for warning in $warnings; do
		print_warning $warning
	done
}

restore_backup() {
  local branch
  local -a branch_paths

  # rebased branches
  branches=( ${(f)"$(yq r $file 'rebase.*.*')"} )
  # stage branches
  branches+=( ${(f)"$(yq r $file 'stage.*.*.*')"} )

  for branch in $branches; do
  	print_log "Restoring $branch"
  	(( quiet )) || print_log "git switch ${quiet:+--quiet }-C $branch $BACKUP_PREFIX/$branch"

  	if (( quiet )); then
  		git switch --quiet -C $branch $BACKUP_PREFIX/$branch
  	else
  		git switch -C $branch $BACKUP_PREFIX/$branch
  	fi
  done

  clean
}

write_rebase_todos() {
  local branch
  local branch_value
  local -a branch_values
  local the_exit_code
  local upstream
  local upstream_path
  local -a upstream_paths

  upstream_paths=( ${(f)"$(yq r --printMode p $file 'rebase.*')"} )
  for upstream_path in $upstream_paths; do
    branch_values=( ${(f)"$(yq r --stripComments $file $upstream_path)"} )
    upstream=${upstream_path#rebase.}
    for branch_value in $branch_values; do
      branch=${branch_value#- }
      add_todo "rebase ${upstream_path#rebase.} $branch"
    done
  done
}

write_staging_todos() {
  local branch
  local branch_path
  local -a branch_paths
  local commit
  local commit_path
  local -a commit_paths
  local start_point
  local start_point_path
  local -a start_point_paths

  start_point_paths=( ${(f)"$(yq r --printMode p $file 'stage.*')"} )

  for start_point_path in $start_point_paths; do
    start_point=${start_point_path#stage.}
    branch_paths=( ${(f)"$(yq r --printMode p $file $start_point_path.\*)"} )

    for branch_path in $branch_paths; do
      branch=${branch_path#$start_point_path.}
      commit_paths=( ${(f)"$(yq r $file $branch_path)"} )
			add_todo "stage-start $branch $start_point"

      for commit_path in $commit_paths; do
        commit=${commit_path#- }
      	add_todo "merge $commit $branch"
      done

      add_todo "stage-end $branch"
    done
  done
}

emulate -L zsh

'builtin' 'setopt' prompt_percent

root=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ -z $root ]]; then
  print_log "Not a Git repo"
  return
fi

readonly BACKUP_PREFIX="git-renew"

mkdir -p ${TMPDIR:-/tmp/}git-replay

todo_dir=$root/.git/replay
todo_path=${todo_dir}/git-replay-todos

file=$root/git-replay.yaml

typeset -i back_up
typeset -A color
typeset -i dry_run
quiet=
typeset -i quieter
typeset -i queue_stages
typeset -i queue_rebases
typeset -a warnings

queue_stages=1
queue_rebases=1

if ! (( ${+NO_COLOR} )); then
  autoload -U colors && colors
  color+=(
  	[error]="%F{red}"
  	[success]="%F{green}"
  	[log]="%F{blue}"
  	[warning]="%F{yellow}"
	)
fi

main $@
