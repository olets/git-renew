#!/usr/bin/env zsh

# git-replay
# copyright 2020 Henry Bley-Vroman
#
# Automate Git rebases and stage creation
# https://github.com/olets/git-replay

abort() {
	if [[ -f $action_path ]]; then
		case $(head -1 $action_path) in
			merge)
				git merge --abort
				;;
			rebase)
				git rebase --abort
				;;
		esac
	fi
	rm -rf $dir
}

add_rebase() {
	local branch
	local upstream

	[[ $# < 2 ]] && print_error "Requires two arguments (upstream and branch)"

	branch=$2
	upstream=$1

	yq w -i $file "rebase.${upstream}[+]" $branch
}

add_rebase_onto() {
	local branch
	local upstream
	local start_point

	[[ $# < 3 ]] && print_error "Requires three arguments (newbase, upstream, and branch)"

	branch=$3
	newbase=$1
	upstream=$2

	yq w -i $file "rebase-onto.$newbase.${upstream}[+]" $branch
}

add_stage() {
	local branch
	local upstream
	local start_point

	[[ $# < 3 ]] && print_error "Requires three arguments (starting point, upstream, and branch)"

	branch=$3
	start_point=$1
	upstream=$2

	yq w -i $file "stage.$start_point.${upstream}[+]" $branch
}

delete_backups() {
	local -a branches

	branches=( ${(f)"$(git for-each-ref --format='%(refname:short)' refs/heads/$BACKUP_PREFIX)"} )
	[[ -z $branches ]] && print_warning "No backup found" && return

	print_log "Deleting all backups"

	if (( quiet )); then
		git branch --quiet -D $branches
	else
		print_log "git branch ${quiet:+--quiet }-D $branches"
		git branch -D $branches
	fi
}

delete_rebase() {
	local branch
	local upstream

	(( $# )) || print_error "Requires one to two arguments (upstream, branch)"

	branch=$2
	upstream=$1

	if [[ -n $branch ]]; then
		yq d -i $file rebase.$upstream.$branch
		[[ -z $(yq r $file rebase.$upstream.\*) ]] && yq d -i $file rebase.$upstream
	else
		yq d -i $file rebase.$upstream
	fi
}

delete_rebase_onto() {
	local branch
	local newbase
	local upstream

	(( $# )) || print_error "Requires one to three arguments (newbase, upstream, and branch)"

	branch=$3
	newbase=$1
	upstream=$2

	if [[ -n $branch ]]; then
		yq d -i $file rebase-onto.$newbase.$upstream.$branch

		[[ -z $(yq r $file rebase-onto.$newbase.$upstream.\*) ]] && yq d -i $file rebase-onto.$newbase.$upstream
		[[ -z $(yq r $file rebase-onto.$newbase.\*) ]] && yq d -i $file rebase-onto.$newbase
	elif [[ -n $upstream ]]; then
		yq d -i $file rebase-onto.$newbase.$upstream

		[[ -z $(yq r $file rebase-onto.$newbase.\*) ]] && yq d -i $file rebase-onto.$newbase
	else
		yq d -i $file rebase-onto.$newbase
	fi
}

delete_stage() {
	local branch
	local start_point
	local upstream

	(( $# )) || print_error "Requires one to three arguments (starting point, upstream, and branch)"

	branch=$3
	start_point=$1
	upstream=$2

	if [[ -n $branch ]]; then
		yq d -i $file stage.$start_point.$upstream.$branch

		[[ -z $(yq r $file stage.$start_point.$upstream.\*) ]] && yq d -i $file stage.$start_point.$upstream
		[[ -z $(yq r $file stage.$start_point.\*) ]] && yq d -i $file stage.$start_point
	elif [[ -n $upstream ]]; then
		yq d -i $file stage.$start_point.$upstream

		[[ -z $(yq r $file stage.$start_point.\*) ]] && yq d -i $file stage.$start_point
	else
		yq d -i $file stage.$start_point
	fi
}

diverged(){
	local branch
	local remote_sha

	branch=$1
	remote_sha=$(git rev-parse $branch@{u} 2>/dev/null)

	if [[ -n $remote_sha && $remote_sha != $(git rev-parse $branch) ]]; then
		mkdir -p $dir
		touch $warning_path

		echo "$branch has diverged from its upstream" >> $warning_path
	fi
}

do_todos() {
	local cmd
	local -a cmd_words
	local todo

	todo=$(head -n 1 $todo_path)

	if [[ -n $todo ]]; then
		todos_updated=$(mktemp ${TMPDIR:-/tmp/}git-replay/git-replay-todos_updated.XXXXXX)
		sed '1d' $todo_path > $todos_updated
		mv $todos_updated $todo_path

		cmd_words=( ${(z)todo} )

		case $cmd_words[1] in
			merge)
				local branch
				local commit
				local -i the_exit_code

				branch=$cmd_words[3]
				commit=$cmd_words[2]

				touch $action_path
				echo merge > $action_path

				print_log "Merging $commit into $branch"
				(( quiet )) || print_log "git merge ${quiet:+"--quiet "}--rerere-autoupdate --no-ff --no-edit $commit"

				if ! (( dry_run )); then
					if (( quiet )); then
						git merge --quiet --rerere-autoupdate --no-ff --no-edit $commit
						the_exit_code=$?
					else
						git merge --rerere-autoupdate --no-ff --no-edit $commit
						the_exit_code=$?
					fi

					(( the_exit_code )) && merge_continue $commit $branch $the_exit_code
				fi

				rm $action_path
				;;
			merge-continue)
				local branch
				local commit

				branch=$cmd_words[3]
				commit=$cmd_words[2]

				print_log "Continuing merging $commit into $branch"
				git rerere && merge_continue $commit $branch

				rm $action_path
				;;
			rebase)
				local branch
				local -i the_exit_code
				local upstream

				branch=$cmd_words[3]
				upstream=$cmd_words[2]

				touch $action_path
				echo rebase > $action_path

				if (( back_up )); then
					print_log "Backing up $branch"
					(( quiet )) || print_log "git branch ${quiet:+"--quiet "}--force git-renew/$branch $branch"

					if ! (( dry_run )); then
						if (( quiet )); then
							git branch --quiet --force git-renew/$branch $branch || return
						else
							git branch --force git-renew/$branch $branch || return
						fi
					fi
				fi

				print_log "Rebasing $branch off $upstream"
				(( quiet )) || print_log "git rebase ${quiet:+"--quiet "}--rerere-autoupdate $upstream $branch"

				if ! (( dry_run )); then
					if (( quiet )); then
						git rebase --quiet --rerere-autoupdate $upstream $branch
						the_exit_code=$?
					else
						git rebase --rerere-autoupdate $upstream $branch
						the_exit_code=$?
					fi

					(( the_exit_code )) && rebase_continue $the_exit_code $upstream $branch
					diverged $branch
				fi

				rm $action_path
				;;
			rebase-continue)
				local branch
				local newbase
				local upstream

				branch=$cmd_words[3]
				newbase=$cmd_words[4]
				upstream=$cmd_words[2]

				if [[ -n $newbase ]]; then
					print_log "Continuing rebasing $branch onto $newbase from $upstream"
				else
					print_log "Continuing rebasing $branch off $upstream"
				fi

				(( quiet )) || print_log "git rerere"

				if ! (( dry_run )); then
					if (( quiet )); then
						git rerere 1>/dev/null
					else
						git rerere
					fi

					rebase_continue 0 $upstream $branch
					set -x
					diverged $branch
					set +x
				fi

				rm $action_path
				;;
			rebase-onto)
				local branch
				local -i the_exit_code
				local newbase
				local upstream

				branch=$cmd_words[4]
				newbase=$cmd_words[2]
				upstream=$cmd_words[3]

				touch $action_path
				echo rebased > $action_path

				if (( back_up )); then
					print_log "Backing up $branch"
					(( quiet )) || print_log "git branch ${quiet:+"--quiet "}--force git-renew/$branch $branch"

					if ! (( dry_run )); then
						if (( quiet )); then
							git branch --quiet --force git-renew/$branch $branch || return
						else
							git branch --force git-renew/$branch $branch || return
						fi
					fi
				fi

				print_log "Rebasing $branch onto $newbase from $upstream"
				(( quiet )) || print_log "git rebase ${quiet:+"--quiet "}--rerere-autoupdate --onto $newbase $upstream $branch"

				if ! (( dry_run )); then
					if (( quiet )); then
						git rebase --quiet --rerere-autoupdate --onto $newbase $upstream $branch
						the_exit_code=$?
					else
						git rebase --rerere-autoupdate --onto $newbase $upstream $branch
						the_exit_code=$?
					fi

					(( the_exit_code )) && rebase_continue $the_exit_code $upstream $branch $newbase
					diverged $branch
				fi

				rm $action_path
				;;
			stage-end)
				local branch

				branch=$cmd_words[2]

				(( dry_run )) || diverged $branch
				;;
			stage-start)
				local branch
				local start_point

				branch=$cmd_words[2]
				start_point=$cmd_words[3]

				if (( back_up )); then
					print_log "Backing up $branch"
					(( quiet )) || print_log "git branch ${quiet:+"--quiet "}--force git-renew/$branch $branch"

					if ! (( dry_run )); then
						if (( quiet )); then
							git branch --quiet --force git-renew/$branch $branch || return
						else
							git branch --force git-renew/$branch $branch || return
						fi
					fi
				fi

				print_log "Resetting $branch to $start_point"
				(( quiet )) || print_log "git switch ${quiet:+"--quiet "}-C $branch $start_point"

				if ! (( dry_run )); then
					if (( quiet )); then
						git switch --quiet -C $branch $start_point || return
					else
						git switch -C $branch $start_point || return
					fi
				fi
				;;
			*)
				print_error "git-replay can not run the todo \`$todo'"
				;;
		esac

		do_todos
	fi

	# this end is hit many times. why??
}

print_error() {
	warnings
	print -P "$color[error]$@%f"
	exit 1
}

main() {
	while (( $# )); do
		case $1 in
			--abort)
				abort
				return
				;;
			--continue)
				[[ -f $todo_path ]] || print_error "fatal: No replay in progress?"
				queue_rebases=0
				queue_stages=0
				shift
				;;
			--back-up)
				back_up=1
				shift
				;;
			--dry-run)
				dry_run=1
				shift
				;;
			--file)
				file=$2
				shift 2
				;;
			-q|\
			--quiet)
				quiet=1
				shift
				;;
			-qq|\
			--quieter)
				quieter=1
				shift
				;;
			add)
				shift
				case $1 in
					rebase)
						shift
						add_rebase $@
						return
						;;
					rebase-onto)
						shift
						add_rebase_onto $@
						;;
					stage)
						shift
						add_stage $@
						return
						;;
					*)
						print_error "git-replay 'add' requires 'rebase', 'rebase-onto', or 'stage'"
						return
						;;
				esac
				return
				;;
			delete-backups)
				delete_backups
				return
				;;
			delete)
				shift
				case $1 in
					rebase)
						shift
						delete_rebase $@
						;;
					rebase-onto)
						shift
						delete_rebase_onto $@
						;;
					stage)
						shift
						delete_stage $@
						;;
					*)
						print_error "git-replay 'delete' requires 'rebase', 'rebase-onto', or 'stage'"
						;;
				esac
				return
				;;
			rebase)
				queue_rebase_ontos=0
				queue_stages=0
				shift
				;;
			rebase-onto)
				queue_rebases=0
				queue_stages=0
				shift
				;;
			restore)
				restore_backup
				return
				;;
			stage)
				queue_rebases=0
				queue_rebase_ontos=0
				shift
				;;
			*)
				print_error "git-replay unknown option"
				;;
		esac
	done

	if ! [[ -f $file ]]; then
		print_error "Could not find the file $file"
	fi

	mkdir -p $dir
	touch $todo_path

	(( queue_rebases )) && write_rebase_todos
	(( queue_rebase_ontos )) && write_rebase_onto_todos
	(( queue_stages )) && write_staging_todos

	do_todos && rm $todo_path
	print_log git-replay completed
	warnings && rm $warning_path

	[[ -f $todo_path || -f $warning_path ]] || abort
}

merge_continue() {
	local branch
	local commit
	local -i the_exit_code

	branch=$2
	commit=$1
	the_exit_code=$3

	if [[ $the_exit_code == 128 || ! $(git config rerere.enabled) == true ]]; then
		print_error "Cannot continue"
	fi

	if [[ -n $(git rerere remaining) ]]; then
		todos_updated=$(mktemp ${TMPDIR:-/tmp/}git-replay/git-replay-todos_updated.XXXXXX)
		echo "merge-continue $commit $branch" > $todos_updated
		cat $todo_path >> $todos_updated
		mv $todos_updated $todo_path

		diverged $branch
		print_error "Resolve conflicts, then run \`git replay --continue'"
	fi

	print_log "All conflicts resolved by git-rerere"

	conflicted_files=$(git diff --name-only --diff-filter=U)

	if [[ -n $conflicted_files ]]; then
		print_log "Adding rerere-resolved conflicted files"
		(( quiet )) || print_log "git add $conflicted_files"
		git add $conflicted_files
	fi

	(( quiet )) || print_log "git commit --no-edit"
	git commit --no-edit || print_error "Cannot continue"
}

print_log() {
	(( quieter )) || print -P "$color[log]$@%f"
}

print_success() {
	(( quieter )) || print -P "$color[success]$@%f"
}

print_warning() {
	(( quieter )) || print -P "$color[warning]$@%f"
}

rebase_continue() {
	local branch
	local -i the_exit_code
	local newbase
	local upstream

	branch=$3
	the_exit_code=$1
	newbase=$4
	upstream=$2

	if [[ $the_exit_code == 128 || ! $(git config rerere.enabled) == true ]]; then
		print_error "Cannot continue"
	fi

	if [[ -n $(git rerere remaining) ]]; then
		todos_updated=$(mktemp ${TMPDIR:-/tmp/}git-replay/git-replay-todos_updated.XXXXXX)
		echo "rebase-continue $upstream $branch $newbase" > $todos_updated
		cat $todo_path >> $todos_updated
		mv $todos_updated $todo_path

		diverged $branch
		print_error "Resolve conflicts, then run \`git replay --continue'"
	fi

	print_log "All conflicts resolved by git-rerere"

	conflicted_files=$(git diff --name-only --diff-filter=U)

	if [[ -n $conflicted_files ]]; then
		print_log "Adding rerere-resolved conflicted files"
		(( quiet )) || print_log "git add $conflicted_files"
		git add $conflicted_files
	fi

	(( quiet )) || print_log "git commit --no-edit && git rebase --continue"
	git commit --no-edit || print_error "Cannot continue"
	git rebase --continue || rebase_continue $? $upstream $branch $newbase
}

restore_backup() {
	local branch
	local -a branch_paths

	# rebased branches
	branches=( ${(f)"$(yq r $file 'rebase.*.*')"} )
	# stage branches
	branches+=( ${(f)"$(yq r $file 'stage.*.*.*')"} )

	for branch in $branches; do
		print_log "Restoring $branch"
		(( quiet )) || print_log "git switch ${quiet:+--quiet }-C $branch $BACKUP_PREFIX/$branch"

		if (( quiet )); then
			git switch --quiet -C $branch $BACKUP_PREFIX/$branch
		else
			git switch -C $branch $BACKUP_PREFIX/$branch
		fi
	done

	delete_backups
}

warnings() {
	[[ -f $warning_path ]] || return

	local -a warnings

	warnings=( ${(f)"$(cat $warning_path)"} )
	typeset -U warnings

	for warning in $warnings; do
		print_warning $warning
	done
}

write_rebase_todos() {
	local branch
	local branch_value
	local -a branch_values
	local the_exit_code
	local upstream
	local upstream_path
	local -a upstream_paths

	upstream_paths=( ${(f)"$(yq r --stripComments --printMode p $file 'rebase.*')"} )
	for upstream_path in $upstream_paths; do
		branch_values=( ${(f)"$(yq r --stripComments $file $upstream_path)"} )
		upstream=${upstream_path#rebase.}
		for branch_value in $branch_values; do
			branch=${branch_value#- }
			echo "rebase ${upstream_path#rebase.} $branch" >> $todo_path
		done
	done
}

write_rebase_onto_todos() {
	local upstream
	local upstream_path
	local -a upstream_paths
	local branch
	local -a branches
	local newbase
	local newbase_path
	local -a newbase_paths

	newbase_paths=( ${(f)"$(yq r --stripComments --printMode p $file 'rebase-onto.*')"} )

	for newbase_path in $newbase_paths; do
		newbase=${newbase_path#rebase-onto.}
		upstream_paths=( ${(f)"$(yq r --stripComments --printMode p $file $newbase_path.\*)"} )

		for upstream_path in $upstream_paths; do
			upstream=${upstream_path#$newbase_path.}
			branches=( ${(f)"$(yq r $file $upstream_path.\*)"} )

			for branch in $branches; do
				echo "rebase-onto $newbase $upstream $branch" >> $todo_path
			done
		done
	done
}

write_staging_todos() {
	local branch
	local branch_path
	local -a branch_paths
	local commit
	local -a commits
	local start_point
	local start_point_path
	local -a start_point_paths

	start_point_paths=( ${(f)"$(yq r --stripComments --printMode p $file 'stage.*')"} )

	for start_point_path in $start_point_paths; do
		start_point=${start_point_path#stage.}
		branch_paths=( ${(f)"$(yq r --stripComments --printMode p $file $start_point_path.\*)"} )

		for branch_path in $branch_paths; do
			branch=${branch_path#$start_point_path.}
			commits=( ${(f)"$(yq r $file $branch_path.\*)"} )
			echo "stage-start $branch $start_point" >> $todo_path

			for commit in $commits; do
				echo "merge $commit $branch" >> $todo_path
			done

			echo "stage-end $branch" >> $todo_path
		done
	done
}

emulate -L zsh

'builtin' 'setopt' prompt_percent

root=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ -z $root ]]; then
	print_log "Not a Git repo"
	return
fi

readonly BACKUP_PREFIX="git-renew"

mkdir -p ${TMPDIR:-/tmp/}git-replay

dir=$root/.git/replay
todo_path=${dir}/git-replay-todos
warning_path=${dir}/git-replay-warnings
action_path=${dir}/git-replay-current-action

file=$root/git-replay.yaml

typeset -i back_up
typeset -A color
typeset -i dry_run
typeset -i queue_rebases
typeset -i queue_rebase_ontos
typeset -i queue_stages
local quiet
typeset -i quieter
typeset -a warnings

queue_rebases=1
queue_rebase_ontos=1
queue_stages=1

if ! (( ${+NO_COLOR} )); then
	autoload -U colors && colors
	color+=(
		[error]="%F{red}"
		[success]="%F{green}"
		[log]="%F{blue}"
		[warning]="%F{yellow}"
	)
fi

main $@
