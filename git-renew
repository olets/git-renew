#!/usr/bin/env zsh

# git-renew
# copyright 2020 Henry Bley-Vroman
#
# Automate Git rebases and stage creation
# https://github.com/olets/git-renew


log_failure() {
  print -P "$failure_color${prefix}Did not succeed%f"
}

log_message() {
  print -P "$log_color${prefix}$1%f"
}

log_success() {
  print -P "$success_color${prefix}Succeeded%f"
}

rebase() {
  local branch
  local branch_value
  local -a branch_values
  local exit_code
  local file
  local upstream
  local upstream_path
  local -a upstream_paths

  log_message "Rebasing..."

  file=$1

  upstream_paths=( ${(f)"$(yq r --printMode p $file 'rebase.*')"} )
  for upstream_path in $upstream_paths; do
    branch_values=( ${(f)"$(yq r $file $upstream_path)"} )
    upstream=${upstream_path#rebase.}
    for branch_value in $branch_values; do
      branch=${branch_value#- }

      run git rebase --rerere-autoupdate ${upstream_path#rebase.} $branch \
        || resolve_conflict

      log_divergence $branch
    done
  done
}

resolve_conflict() {
  local conflicted_files
  log_message "Attempting automatic continuation"

  conflicted_files=$(git diff --name-only --diff-filter=U)

  if [[ $(git config rerere.enabled) == true \
        && -z $(git rerere remaining) ]]; then
    print -P "$log_color${prefix}All conflicts resolved by git-rerere%f"
    run git add $conflicted_files \
      || exit
    run git commit --no-edit \
      || exit
  else
    log_failure
    exit
  fi
  return 0
}

run() {
  # Input: a command
  #
  # log_message the command, run it, log_message whether it
  # succeeded or failed, and return its return 1 code.
  # Drop-in replacement for just running it.

  local -i exit_code

  print -P "$run_color$prefix$@%f"
  $@
  exit_code=$?

  if (( exit_code )); then
    log_failure
  else
    log_success
  fi

  return $exit_code
}

stage() {
  local branch
  local branch_path
  local -a branch_paths
  local commit
  local commit_path
  local -a commit_paths
  local file
  local start_point
  local start_point_path
  local -a start_point_paths

  log_message "Staging..."

  file=$1

  start_point_paths=( ${(f)"$(yq r --printMode p $file 'stage.*')"} )

  for start_point_path in $start_point_paths; do
    start_point=${start_point_path#stage.}
    branch_paths=( ${(f)"$(yq r --printMode p $file $start_point_path.\*)"} )

    for branch_path in $branch_paths; do
      branch=${branch_path#$start_point_path.}
      commit_paths=( ${(f)"$(yq r $file $branch_path)"} )

      run git switch -C $branch $start_point
      if (( $? )); then
        log_failure && exit
      fi

      for commit_path in $commit_paths; do
        commit=${commit_path#- }

        run git merge --rerere-autoupdate --no-ff --no-edit $commit \
          || resolve_conflict
      done

      log_divergence $branch
      run git switch -
    done
  done
}

log_divergence() {
  # Input: a branch name
  #
  # If the branch has diverged from its upstream, say so immediately
  # and at the of the script

  # Commit ID for the upstream, if there is an upstream
  local message
  local upstream
  upstream=$(git rev-parse $1@{u} 2>/dev/null)

  # If there's an upstream and its commit ID is not the same as the local branch's
  if [[ -n $upstream && $upstream != $(git rev-parse $1) ]]; then
    message="$warn_color${prefix}$1 has diverged from its upstream%f"
    print -P $message
    messages+="$message\\n"
  fi
}

'builtin' 'setopt' prompt_percent

failure_color=
log_color=
messages=
prefix="  â–¶ "
run_color=
success_color=
warn_color=

if ! (( ${+NO_COLOR} )); then
  autoload -U colors && colors
  failure_color="%F{red}"
  log_color="%F{magenta}"
  run_color="%F{blue}"
  success_color="%F{green}"
  warn_color="%F{yellow}"
fi


local file=${1:-$PWD/git-renew.yaml}

rebase $file
stage $file
[[ -n $messages ]] && print -P \\n$messages
