#!/usr/bin/env zsh

# git-replay
# copyright 2020 Henry Bley-Vroman
#
# Automate Git rebases and stage creation
# https://github.com/olets/git-replay

__git_replay_abort() {
	if [[ -f $action_path ]]; then
		case $(head -1 $action_path) in
			merge)
				git merge --abort
				;;
			rebase)
				git rebase --abort
				;;
		esac
	fi
	rm -rf $dir
}

__git_replay_add_rebase() {
	local branch
	local upstream

	[[ $# < 2 ]] && __git_replay_print_error "Requires two arguments (upstream and branch)"

	branch=$2
	upstream=$1

	'command' 'yq' w -i $file "rebase.${upstream}[+]" $branch
}

__git_replay_add_rebase_onto() {
	local branch
	local upstream
	local start_point

	[[ $# < 3 ]] && __git_replay_print_error "Requires three arguments (newbase, upstream, and branch)"

	branch=$3
	newbase=$1
	upstream=$2

	'command' 'yq' w -i $file "rebase-onto.$newbase.${upstream}[+]" $branch
}

__git_replay_add_stage() {
	local branch
	local upstream
	local start_point

	[[ $# < 3 ]] && __git_replay_print_error "Requires three arguments (starting point, upstream, and branch)"

	branch=$3
	start_point=$1
	upstream=$2

	'command' 'yq' w -i $file "stage.$start_point.${upstream}[+]" $branch
}

__git_replay_backup_delete() {
	local branch
	local backup_branch
	local -a backup_branches

	backup_branches=( ${(f)"$(git for-each-ref --format='%(refname:short)' refs/heads/$BACKUP_PREFIX)"} )
	[[ -z $backup_branches ]] && __git_replay_print_warning "No backup branches found" && return

	__git_replay_print_log "Deleting backups"

	for backup_branch in $backup_branches; do
		branch=${backup_branch#$BACKUP_PREFIX/}

		if ! git show-ref --verify --quiet refs/heads/$branch; then
			mkdir -p $dir
			touch $warning_path

			'builtin' 'echo' "No branch \`$branch\` found. Not deleting the backup in case it is needed.\nTo delete the backup, run\n        git branch -D $backup_branch" >> $warning_path
		else
			if (( quiet )); then
				git branch --quiet -D $backup_branch
			else
				'builtin' 'print' "git branch --quiet -D $backup_branch"
				git branch -D $backup_branch
			fi
		fi
	done
}

__git_replay_backup_restore() {
	local branch
	local backup_branch
	local -a backup_branches

	backup_branches=( ${(f)"$(git for-each-ref --format='%(refname:short)' refs/heads/$BACKUP_PREFIX)"} )
	[[ -z $backup_branches ]] && __git_replay_print_warning "No backup branches found" && return

	__git_replay_print_log "Restoring backed up branches"

	for backup_branch in $backup_branches; do
		branch=${backup_branch#$BACKUP_PREFIX/}

		if git show-ref --verify --quiet refs/heads/$branch; then
			__git_replay_print_log "Restoring $branch"

			if (( quiet )); then
				git checkout --quiet -B $branch $backup_branch
			else
				'builtin' 'print' "git checkout -B $branch $backup_branch"
				git checkout -B $branch $backup_branch
			fi
		fi
	done

	__git_replay_backup_delete
}

__git_replay_delete_rebase() {
	local branch
	local upstream

	(( $# )) || __git_replay_print_error "Requires one to two arguments (upstream, branch)"

	branch=$2
	upstream=$1

	if [[ -n $branch ]]; then
		'command' 'yq' d -i $file rebase.$upstream.$branch
		[[ -z $('command' 'yq' r $file rebase.$upstream.\*) ]] && 'command' 'yq' d -i $file rebase.$upstream
	else
		'command' 'yq' d -i $file rebase.$upstream
	fi
}

__git_replay_delete_rebase_onto() {
	local branch
	local newbase
	local upstream

	(( $# )) || __git_replay_print_error "Requires one to three arguments (newbase, upstream, and branch)"

	branch=$3
	newbase=$1
	upstream=$2

	if [[ -n $branch ]]; then
		'command' 'yq' d -i $file rebase-onto.$newbase.$upstream.$branch

		[[ -z $('command' 'yq' r $file rebase-onto.$newbase.$upstream.\*) ]] && 'command' 'yq' d -i $file rebase-onto.$newbase.$upstream
		[[ -z $('command' 'yq' r $file rebase-onto.$newbase.\*) ]] && 'command' 'yq' d -i $file rebase-onto.$newbase
	elif [[ -n $upstream ]]; then
		'command' 'yq' d -i $file rebase-onto.$newbase.$upstream

		[[ -z $('command' 'yq' r $file rebase-onto.$newbase.\*) ]] && 'command' 'yq' d -i $file rebase-onto.$newbase
	else
		'command' 'yq' d -i $file rebase-onto.$newbase
	fi
}

__git_replay_delete_stage() {
	local branch
	local start_point
	local upstream

	(( $# )) || __git_replay_print_error "Requires one to three arguments (starting point, upstream, and branch)"

	branch=$3
	start_point=$1
	upstream=$2

	if [[ -n $branch ]]; then
		'command' 'yq' d -i $file stage.$start_point.$upstream.$branch

		[[ -z $('command' 'yq' r $file stage.$start_point.$upstream.\*) ]] && 'command' 'yq' d -i $file stage.$start_point.$upstream
		[[ -z $('command' 'yq' r $file stage.$start_point.\*) ]] && 'command' 'yq' d -i $file stage.$start_point
	elif [[ -n $upstream ]]; then
		'command' 'yq' d -i $file stage.$start_point.$upstream

		[[ -z $('command' 'yq' r $file stage.$start_point.\*) ]] && 'command' 'yq' d -i $file stage.$start_point
	else
		'command' 'yq' d -i $file stage.$start_point
	fi
}

__git_replay_diverged(){
	local branch
	local remote_sha

	branch=$1
	remote_sha=$(git rev-parse $branch@{u} 2>/dev/null)

	if [[ -n $remote_sha && $remote_sha != $(git rev-parse $branch) ]]; then
		mkdir -p $dir
		touch $warning_path

		'builtin' 'echo' "$branch has diverged from its upstream" >> $warning_path
	fi
}

__git_replay_do_todo() {
	local -a cmd_words

	cmd_words=( ${(z)1} )

	case $cmd_words[1] in
		merge)
			local branch
			local commit
			local -i the_exit_code

			branch=$cmd_words[3]
			commit=$cmd_words[2]

			touch $action_path
			'builtin' 'echo' merge > $action_path

			__git_replay_print_log "Merging $commit into $branch"

			if ! (( dry_run )); then
				if (( quiet )); then
					git merge --quiet --rerere-autoupdate --no-ff --no-edit $commit
					the_exit_code=$?
				else
					'builtin' 'print' "git merge --rerere-autoupdate --no-ff --no-edit $commit"
					git merge --rerere-autoupdate --no-ff --no-edit $commit
					the_exit_code=$?
				fi

				(( the_exit_code )) && __git_replay_merge_continue $commit $branch $the_exit_code
			fi

			rm $action_path
			;;
		merge-continue)
			local branch
			local commit

			branch=$cmd_words[3]
			commit=$cmd_words[2]

			__git_replay_print_log "Continuing merging $commit into $branch"
			git rerere && __git_replay_merge_continue $commit $branch

			rm $action_path
			;;
		rebase)
			local branch
			local -i the_exit_code
			local upstream

			branch=$cmd_words[3]
			upstream=$cmd_words[2]

			touch $action_path
			'builtin' 'echo' rebase > $action_path

			if (( back_up )); then
				__git_replay_print_log "Backing up $branch"

				if ! (( dry_run )); then
					if (( quiet )); then
						git branch --quiet --force $BACKUP_PREFIX/$branch $branch || return
					else
						'builtin' 'print' "git branch --force $BACKUP_PREFIX/$branch $branch"
						git branch --force $BACKUP_PREFIX/$branch $branch || return
					fi
				fi
			fi

			__git_replay_print_log "Rebasing $branch off $upstream"

			if ! (( dry_run )); then
				if (( quiet )); then
					git rebase --quiet --rerere-autoupdate $upstream $branch
					the_exit_code=$?
				else
					'builtin' 'print' "git rebase --rerere-autoupdate $upstream $branch"
					git rebase --rerere-autoupdate $upstream $branch
					the_exit_code=$?
				fi

				(( the_exit_code )) && __git_replay_rebase_continue $the_exit_code $upstream $branch
				__git_replay_diverged $branch
			fi

			rm $action_path
			;;
		rebase-continue)
			local branch
			local newbase
			local upstream

			branch=$cmd_words[3]
			newbase=$cmd_words[4]
			upstream=$cmd_words[2]

			if [[ -n $newbase ]]; then
				__git_replay_print_log "Continuing rebasing $branch onto $newbase from $upstream"
			else
				__git_replay_print_log "Continuing rebasing $branch off $upstream"
			fi

			if ! (( dry_run )); then
				(( quiet )) || 'builtin' 'print' "git rerere"
				git rerere

				__git_replay_rebase_continue 0 $upstream $branch
				__git_replay_diverged $branch
			fi

			rm $action_path
			;;
		rebase-onto)
			local branch
			local -i the_exit_code
			local newbase
			local upstream

			branch=$cmd_words[4]
			newbase=$cmd_words[2]
			upstream=$cmd_words[3]

			touch $action_path
			'builtin' 'echo' rebased > $action_path

			if (( back_up )); then
				__git_replay_print_log "Backing up $branch"

				if ! (( dry_run )); then
					if (( quiet )); then
						git branch --quiet --force $BACKUP_PREFIX/$branch $branch || return
					else
						'builtin' 'print' "git branch --force $BACKUP_PREFIX/$branch $branch"
						git branch --force $BACKUP_PREFIX/$branch $branch || return
					fi
				fi
			fi

			__git_replay_print_log "Rebasing $branch onto $newbase from $upstream"

			if ! (( dry_run )); then
				if (( quiet )); then
					git rebase --quiet --rerere-autoupdate --onto $newbase $upstream $branch
					the_exit_code=$?
				else
					'builtin' 'print' "git rebase --rerere-autoupdate --onto $newbase $upstream $branch"
					git rebase --rerere-autoupdate --onto $newbase $upstream $branch
					the_exit_code=$?
				fi

				(( the_exit_code )) && __git_replay_rebase_continue $the_exit_code $upstream $branch $newbase
				__git_replay_diverged $branch
			fi

			rm $action_path
			;;
		stage-end)
			local branch

			branch=$cmd_words[2]

			(( dry_run )) || __git_replay_diverged $branch
			;;
		stage-start)
			local branch
			local start_point

			branch=$cmd_words[2]
			start_point=$cmd_words[3]

			if (( back_up )); then
				__git_replay_print_log "Backing up $branch"

				if ! (( dry_run )); then
					if (( quiet )); then
						git branch --quiet --force $BACKUP_PREFIX/$branch $branch || return
					else
						'builtin' 'print' "git branch --force $BACKUP_PREFIX/$branch $branch"
						git branch --force $BACKUP_PREFIX/$branch $branch || return
					fi
				fi
			fi

			__git_replay_print_log "Resetting $branch to $start_point"

			if ! (( dry_run )); then
				if (( quiet )); then
					git checkout --quiet -B $branch $start_point || return
				else
					'builtin' 'print' "git checkout -B $branch $start_point"
					git checkout -B $branch $start_point || return
				fi
			fi
			;;
		*)
			__git_replay_print_error "git-replay can not run the todo \`$todo'"
			;;
	esac
}

__git_replay_print_error() {
	__git_replay_warnings
	'builtin' 'print' -P "$color[error]$@%f"
	'builtin' 'exit' 1
}

__git_replay_main() {
	local -i continue
	local -i queue_rebases
	local -i queue_rebase_ontos
	local -i queue_stages
	local -a todos

	queue_rebases=1
	queue_rebase_ontos=1
	queue_stages=1

	while (( $# )); do
		case $1 in
			--abort)
				__git_replay_abort
				return
				;;
			--continue)
				[[ -f $todo_path ]] || __git_replay_print_error "fatal: No replay in progress?"
				continue=1
				queue_rebases=0
				queue_stages=0
				shift
				;;
			--back-up)
				back_up=1
				shift
				;;
			--dry-run)
				dry_run=1
				shift
				;;
			--file)
				file=$2
				shift 2
				;;
			-q|\
			--quiet)
				quiet=1
				shift
				;;
			-qq|\
			--quieter)
				quiet=1
				quieter=1
				shift
				;;
			--skip)
				[[ -f $todo_path ]] || __git_replay_print_error "fatal: No replay in progress?"
				continue=1
				queue_rebases=0
				queue_stages=0
				__git_replay_pop_todo
				shift
				;;
			add)
				shift
				case $1 in
					rebase)
						shift
						__git_replay_add_rebase $@
						return
						;;
					rebase-onto)
						shift
						__git_replay_add_rebase_onto $@
						;;
					stage)
						shift
						__git_replay_add_stage $@
						return
						;;
					*)
						__git_replay_print_error "git-replay 'add' requires 'rebase', 'rebase-onto', or 'stage'"
						return
						;;
				esac
				return
				;;
			backup-delete)
				__git_replay_backup_delete
				__git_replay_warnings && rm $warning_path
				return
				;;
			backup-restore)
				__git_replay_backup_restore
				__git_replay_warnings && rm $warning_path
				return
				;;
			delete)
				shift
				case $1 in
					rebase)
						shift
						__git_replay_delete_rebase $@
						;;
					rebase-onto)
						shift
						__git_replay_delete_rebase_onto $@
						;;
					stage)
						shift
						__git_replay_delete_stage $@
						;;
					*)
						__git_replay_print_error "git-replay 'delete' requires 'rebase', 'rebase-onto', or 'stage'"
						;;
				esac
				return
				;;
			rebase)
				queue_rebase_ontos=0
				queue_stages=0
				shift
				;;
			rebase-onto)
				queue_rebases=0
				queue_stages=0
				shift
				;;
			stage)
				queue_rebases=0
				queue_rebase_ontos=0
				shift
				;;
			*)
				__git_replay_print_error "git-replay unknown option"
				;;
		esac
	done

	if ! [[ -f $file ]]; then
		__git_replay_print_error "Could not find the file $file"
	fi

	if [[ -f $todo_path ]] && ! (( continue )); then
		__git_replay_print_error "fatal: It seems that there is already a replay todo file, and\nI wonder if you are in the middle of another replay.  If that is the\ncase, please try\n        git replay [--file <file>] (--continue | --abort | --skip)\nIf that is not the case, please\n        rm \".git/git-replay-todos\"\nand run me again.  I am stopping in case you still have something\nvalueable there."
	fi

	mkdir -p $dir
	touch $todo_path

	(( queue_rebases )) && __git_replay_write_rebase_todos
	(( queue_rebase_ontos )) && __git_replay_write_rebase_onto_todos
	(( queue_stages )) && __git_replay_write_staging_todos

	todos=( ${(f)"$('command' 'cat' $todo_path)"} )
	for todo in $todos; do
		__git_replay_do_todo $todo
		__git_replay_pop_todo
	done

	__git_replay_pop_todo
	rm $todo_path

	__git_replay_print_log Replay complete
	__git_replay_warnings && rm $warning_path

	[[ -f $todo_path || -f $warning_path ]] || __git_replay_abort
}

__git_replay_merge_continue() {
	local branch
	local commit
	local -i the_exit_code

	branch=$2
	commit=$1
	the_exit_code=$3

	if [[ $the_exit_code == 128 || ! $(git config rerere.enabled) == true ]]; then
		__git_replay_print_error "Cannot continue"
	fi

	if [[ -n $(git rerere remaining) ]]; then
		todos_updated=$(mktemp ${TMPDIR:-/tmp/}git-replay/git-replay-todos_updated.XXXXXX)
		'builtin' 'echo' "merge-continue $commit $branch" > $todos_updated
		'command' 'cat' $todo_path >> $todos_updated
		'command' 'mv' $todos_updated $todo_path

		__git_replay_diverged $branch
		__git_replay_print_error "Resolve conflicts, then run \`git replay --continue'"
	fi

	__git_replay_print_log "All conflicts resolved by git-rerere"

	conflicted_files=$(git diff --name-only --diff-filter=U)

	if [[ -n $conflicted_files ]]; then
		__git_replay_print_log "Adding rerere-resolved conflicted files"
		(( quiet )) || 'builtin' 'print' "git add $conflicted_files"
		git add $conflicted_files
	fi

	(( quiet )) || 'builtin' 'print' "git commit --no-edit"
	git commit --no-edit || __git_replay_print_error "Cannot continue"
}

__git_replay_pop_todo() {
	todos_updated=$(mktemp ${TMPDIR:-/tmp/}git-replay/git-replay-todos_updated.XXXXXX)
	'command' 'sed' '1d' $todo_path > $todos_updated
	'command' 'mv' $todos_updated $todo_path
}

__git_replay_print_log() {
	(( quieter )) || 'builtin' 'print' -P "$color[log]$@%f"
}

__git_replay_print_success() {
	(( quieter )) || 'builtin' 'print' -P "$color[success]$@%f"
}

__git_replay_print_warning() {
	(( quieter )) || 'builtin' 'print' -P "$color[warning]$@%f"
}

__git_replay_rebase_continue() {
	local branch
	local -i the_exit_code
	local newbase
	local upstream

	branch=$3
	the_exit_code=$1
	newbase=$4
	upstream=$2

	if [[ $the_exit_code == 128 || ! $(git config rerere.enabled) == true ]]; then
		__git_replay_print_error "Cannot continue"
	fi

	if [[ -n $(git rerere remaining) ]]; then
		todos_updated=$(mktemp ${TMPDIR:-/tmp/}git-replay/git-replay-todos_updated.XXXXXX)
		'builtin' 'echo' "rebase-continue $upstream $branch $newbase" > $todos_updated
		'command' 'cat' $todo_path >> $todos_updated
		'command' 'mv' $todos_updated $todo_path

		__git_replay_diverged $branch
		__git_replay_print_error "Resolve conflicts, then run \`git replay --continue'"
	fi

	__git_replay_print_log "All conflicts resolved by git-rerere"

	conflicted_files=$(git diff --name-only --diff-filter=U)

	if [[ -n $conflicted_files ]]; then
		__git_replay_print_log "Adding rerere-resolved conflicted files"
		(( quiet )) || 'builtin' 'print' "git add $conflicted_files"
		git add $conflicted_files
	fi

	(( quiet )) || 'builtin' 'print' "git commit --no-edit && git rebase --continue"
	git commit --no-edit || __git_replay_print_error "Cannot continue"
	git rebase --continue || __git_replay_rebase_continue $? $upstream $branch $newbase
}

__git_replay_warnings() {
	[[ -f $warning_path ]] || return

	local -a __git_replay_warnings

	__git_replay_warnings=( ${(f)"$('command' 'cat' $warning_path)"} )
	'builtin' 'typeset' -U __git_replay_warnings

	for warning in $__git_replay_warnings; do
		__git_replay_print_warning $warning
	done
}

__git_replay_write_rebase_todos() {
	local branch
	local branch_value
	local -a branch_values
	local the_exit_code
	local upstream
	local upstream_path
	local -a upstream_paths

	upstream_paths=( ${(f)"$('command' 'yq' r --stripComments --printMode p $file 'rebase.*')"} )
	for upstream_path in $upstream_paths; do
		branch_values=( ${(f)"$('command' 'yq' r --stripComments $file $upstream_path)"} )
		upstream=${upstream_path#rebase.}
		for branch_value in $branch_values; do
			branch=${branch_value#- }
			'builtin' 'echo' "rebase ${upstream_path#rebase.} $branch" >> $todo_path
		done
	done
}

__git_replay_write_rebase_onto_todos() {
	local upstream
	local upstream_path
	local -a upstream_paths
	local branch
	local -a branches
	local newbase
	local newbase_path
	local -a newbase_paths

	newbase_paths=( ${(f)"$('command' 'yq' r --stripComments --printMode p $file 'rebase-onto.*')"} )

	for newbase_path in $newbase_paths; do
		newbase=${newbase_path#rebase-onto.}
		upstream_paths=( ${(f)"$('command' 'yq' r --stripComments --printMode p $file $newbase_path.\*)"} )

		for upstream_path in $upstream_paths; do
			upstream=${upstream_path#$newbase_path.}
			branches=( ${(f)"$('command' 'yq' r $file $upstream_path.\*)"} )

			for branch in $branches; do
				'builtin' 'echo' "rebase-onto $newbase $upstream $branch" >> $todo_path
			done
		done
	done
}

__git_replay_write_staging_todos() {
	local branch
	local branch_path
	local -a branch_paths
	local commit
	local -a commits
	local start_point
	local start_point_path
	local -a start_point_paths

	start_point_paths=( ${(f)"$('command' 'yq' r --stripComments --printMode p $file 'stage.*')"} )

	for start_point_path in $start_point_paths; do
		start_point=${start_point_path#stage.}
		branch_paths=( ${(f)"$('command' 'yq' r --stripComments --printMode p $file $start_point_path.\*)"} )

		for branch_path in $branch_paths; do
			branch=${branch_path#$start_point_path.}
			commits=( ${(f)"$('command' 'yq' r $file $branch_path.\*)"} )
			'builtin' 'echo' "stage-start $branch $start_point" >> $todo_path

			for commit in $commits; do
				'builtin' 'echo' "merge $commit $branch" >> $todo_path
			done

			'builtin' 'echo' "stage-end $branch" >> $todo_path
		done
	done
}

emulate -L zsh

'builtin' 'setopt' prompt_percent

root=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ -z $root ]]; then
	__git_replay_print_log "Not a Git repo"
	return
fi

readonly BACKUP_PREFIX="git-replay"

mkdir -p ${TMPDIR:-/tmp/}git-replay

dir=$root/.git/replay
todo_path=${dir}/git-replay-todos
warning_path=${dir}/git-replay-warnings
action_path=${dir}/git-replay-current-action

file=$root/git-replay.yaml

'builtin' 'typeset' -i back_up
'builtin' 'typeset' -A color
'builtin' 'typeset' -i dry_run
'builtin' 'typeset' -i quiet
'builtin' 'typeset' -i quieter
'builtin' 'typeset' -a __git_replay_warnings

if ! (( ${+NO_COLOR} )); then
	autoload -U colors && colors
	color+=(
		[error]="%F{red}"
		[success]="%F{green}"
		[log]="%F{blue}"
		[warning]="%F{yellow}"
	)
fi

__git_replay_main $@
